
                                  INTRODUCTION
  Once I've realized how huge information treasury YouTube is, I've dreamed
about having handy video speed control. One of the most precious resources we have
is time, and using it smartly one can gain big advantages.
  The first step was discovering intrinsic to HTML5 media elements "playbackRate" property.
Some long videos (e.g. tutorials) were too slow when set to 1.5 whereas too fast at double speed.
With Chrome developer tools console it was easy to select a video element via
document.querySelector() and to set it playbackRate to 1.75 was a great solution.
But that was just a temporary crutch.
  After I'd had some experience with Google Chrome Extensions, I've got the vision what I should do.
Creating Video Speeder Extension was rather long but extraordinary informative process. While
doing it I've acquired some useful skills, i.e.:


                                  I JAVASCRIPT PART
    At the beginning I started making this extension for YouTube, but I had plans to extend it for all the
  video tags on the Web. That's why I found it important to divide the code into several semantic bricks.
  It's pretty obvious that code that handle unique YouTube environment is useless in non-YouTube pages, so
  the final structure consists of:
    + manifest.json. Every Chrome Extension has it. Here we describe features from Chrome Extesion API which 
    we are going to use, version, extension descriptions, resourses to use, some security adjustments, etc.
    + content.js. The start point of the extension. It is run in all the pages and iframes that
    have "src" attribute different from "about:blank" and contains default settings and paths. It does:
      - append common.js and a proper script (in dependency of window.location.host);
      - due to the fact that content script have access to some Chrome API (i.e. chrome.runtime and chrome.storage)
      whereas appended scripts don't, content.js is responsible for passing user settings and relative to
      the Extension ID paths to appended scripts via window messaging (an interesting moment: despite the
      fact that a content and an appended scripts share the same window, assignment window.test25 = "passed"
      in content doesn't mean that window.test25 in appended script is equal to "passed",
      actually, it is undefined ).
      - listens to changes in user settings stored in chrome.storage.local and command to common script
      to adjust existing speeders to new settings.
      - handling "target:blank" iframes (explained below);
    + common.js. Prepares convenient environment for narrow specialized appended scripts.
      - gets settings from content script via window messaging (or in short way in case blank iframes);
      - populate window object with speeders array, two functions to create a speeder and a prototype for it,
      and some other auxiliary functions as well. This time common.js script and a proper appended script
      operate in the same scope, that said window.test25 = "passed" in one script means window.test25
      is equal to "passed" in other.
      - gives a permission to appended script to start after common script work is done.
    + case_youtube.js. This specific appended script starts its work right after common.js sends permission
    to do it. YouTube developers made their product looks like single page application (though it is not), and
    whatever video link you click it is always loaded in the same video tag. Thus, once
    MutationObservers callback finds a video tag, it stops observing document tree for new video nodes.
    For better user experience I decided to embed a speeder right in the middle of YouTube control panel.
    But YouTube is built as responsible website, therefore sizing problems for the speeder are guaranteed.
    At first I tried to tackle them using mouse events. It was very complicated, unstable and required
    much additional code. Moreover, it gave additional load to users system. The answer came with
    MutationObserver, focused on "styles" attribute. Should the dimensional styles change, described in
    the YouTube speeders prototype function "resize"  will recalculate new appropriate speeder appearance.
    Clear, light and concise.
    To embed speeder in YouTube page this script adds functions that create:
      - youtube-specific speeders prototype, which contains configs to MutationObservers and
      functions responsible for resizing a speeder.
      - youtube-specific speeder, it includes necessary for rendering DOM environment.
    + case_vk.js is quite similar to previous script, but has some differences. Unlike YouTube,
    mouse click on video links in VK inflicts serious redraw of the DOM tree. And there's more,
    being a dynamically generated page, vk.com can load another video tag, and another, and another.
    That's why MutationObserver has to monitor the DOM tree constantly. Any video tag that hasn't
    been marked as already handled will get its own speeder.
    + case_others.js. We don't know the number of video tags on an arbitrary site, thus the approach to
    handling them is the same as in previous case_vk.js file. MutationObserver finds and handles all
    the video tags while a page isn't closed. The file has its unique feature, it uses Shadow DOM.
    It would require lots of efforts and redundant CSS styles to achieve the same appearance of the speeder
    on different sites on the Web without Shadow DOM. Due to this feature the file styles_others.css has
    comparable with other CSS files size.
    + Facebook case. Does not have its own file. There were little I wanted to adapt with Facebook, just to
    align slider box in the middle of the video near to its bottom. To be honest, my first wish was to go to
    styles for other cases and to write down there a few rules specially for Facebook. But then I realized that
    the whole style file is appended within the shadow root, thus it will have no power over positioning
    shadow host. Apparently, I should append another style file to the same scope where shadow host is. Ok, it's
    not a hard task, but where is the best place to do it? As all the "others" functional is 100% suitable
    for Facebook I find it relevant to make minor features right in case_others.js. So be it, all the small and
    fine adjustments for numerous sites will be handled here.



    + iframe_content.js is in charge of iframe tags with no scr attribute (or with scr set to "target:blank").
    After setting option for content scripts "matches" to "<all_urls>" and "all_frames" to true, it seems like
    content script will run in all pages and in all iframes. It's true, but with one exception, mentioned above.
    That's why content.js separately handles all the blank iframes. Once it find them, it appends there
    iframe_content.js script. The main purpose of it is the same as of the content script with one but
    quite significant distinction: iframe_content.js runs beyond Chrome API scope. On the one hand it
    complicates passing parameters from content script to appended scripts, thus it should be done via window
    messaging. But on the other hand, as iframe_content.js is and appended script, it works in the same scope
    with other appended scripts, therefore, passing parameters is available by assignment values right to
    window properties. Briefly, algorithm looks like in content script:
      - get parameters;
      - append common script;
      - append proper to a window.location.host script;
      - handle blank iframes.


                                OPTIONS PART
     Personally, I like when useful tools are shipped with possibility for custom adjustment. That's why I
  provided users with option page where one can set min, max and default speed plus some other speeder
  parameters as well.
     Technically it wasn't hard, I just specified options_page in the manifest and add options javascript
  and css files to web_accessible_resources. I found no information about options working scope at Chrome
  Developer Guide, but empirically approved that it is possible to use chrome.storage there. So, parameters
  chosen by user are stored in Chrome Local Storage. This way of storage is more preferable
  as it has no dependency on url or type of protocol. Another advantage is that a user can synchronize
  settings on different devices working under the same account.
     I find it hard for an average user to get to options page from Chrome Extensions page, that's
  why I added Video Speeder button to the Chrome Toolbar in the right top part of the browser. When clicked,
  it shows small popup menu, where a user in easy way can switch the extension on/off or open options page.
  As popup's script has access to chrome.storage, I put current state of the extension there. And I was compelled
  to add a background script for the only one purpose to set proper extension icon in Chrome Toolbar when the
  browser is opened first time. It takes current state in chrome.storage, then sets appropriate icon. In short
  words, the logic is:
  - background gets info of the extension state in chrome.storage and sets proper icon;
  - a user clicks the button in Chrome Toolbar and switches the extension;
  - popup.js changes the extension state in chrome.storage;
  - next time content.js runs on page it checks the extension state in chrome.storage,
  and if it is "off" stops working.



                            CONCLUSION
    To draw conclusion, I'd like to state that I achieved all the aims I'd set to myself. The finished
  product is the Google Chrome Extension which allows us to control video tags playback rate in easy and
  convenient way. As a bonus, it has options page with fine adjustments to satisfy any possible users requests.
    I also managed to adapt this initially developed for YouTube Extension to fit to most of the video tags on
  the Web. But why "most" instead of "all"? Well, there can be situations which I can not foresee. It's up to
  a particular  developer to decide how to embed video in markup and how to design them. I saw solutions
  where a video tag was curtained with special screen element (div) to catch all the users mouse events.
  Of course, it can have negative or/and unpredictable effects on the Extension functioning, and for fixing them
  I should see this particular situation. But these are quite rare occasions, that's why I've decided to left
  such a cases without handling to avoid redundant code.
    To be honest, here is another small subgoal I couldn't resolve. For most popular sites (YouTube and VK)
  it's done, but for other sites one can't use the Extension in full-screen mode. Modern browsers don't provide
  developers tools to render something upon full-sized video. Existing tricks and crutches can help to some
  particular case, but not for an arbitrary website. And again, they can noticeably worsen performance.
    While creating this Chrome Extension I:
  1. Enhanced my overall knowledge about Chrome Extension anatomy. Manifest, content script, options page,
  browser actions, different scopes for content script and options and appended scripts.
  2. Used Chrome Storage API (don't mix up with window.localStorage) and windows messaging.
  3. Realized the CSS benefits of the Shadow DOM.
  4. Approved the fact that Mutation Observer is great in replacement of numerous mouse events.
  5. Found and solved issues with running custom scripts in blank iframes.
  6. Shared in "window" functions and variables between different scripts.
  7. Didn't forget to disconnect MutationObserver and remove EventListener when there were no
  need in them to exclude excessive performance load.
  8. Engaged Prototypal Inheritance for better Extension adoption for different sites.
  I divided common part of the code and specific parts, the chain looks like:
    common Prototype (common functions) ->
    specific Prototype (unique for a particular site functions and options ) ->
    common Speeder Object (has all the buttons, inputs and other) ->
    specific Speeder Object (has involved environment relative to video tag ).
  9. Uploaded the Extension code to github.
  10. Published the Extension.



  KEYS CLOUD
MutationObserver, chrome.runtime, prototype, inheritance, browser action, content script, options page,
background page, chrome.storage, popup menu, manifest, passing functions, cross-script messages,
iframes features, playbackRate, Shadow DOM, publishing extensions, github.
